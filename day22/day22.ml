(** {1 Day 22: Monkey Market - Secret Number Trading Challenge}

    This module solves Advent of Code Day 22 challenge about predicting buyer behavior 
    in a monkey market. The module analyzes pseudorandom sequences of secret numbers 
    and price patterns to maximize banana trades.

    {2 Problem Details}
    
    - {b Input:} Initial secret numbers for each buyer in the Monkey Exchange Market
    - {b Part 1:} Calculate sum of 2000th secret number generated by each buyer's algorithm  
    - {b Part 2:} Find optimal price pattern to maximize banana trades across all buyers

    {2 Secret Number Evolution Process}
    Each secret number evolves through a three-step process:
    
    - Multiply by 64, mix (XOR), and prune (modulo 16777216)
    - Divide by 32, mix (XOR), and prune (modulo 16777216) 
    - Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    {b Implementation Note:} The solution uses parallel processing and efficient data 
    structures for performance optimization.

    @see <https://adventofcode.com/2024/day/22> Advent of Code 2024, Day 22
*)



(** Mixes two values using XOR operation 

  - The mixing operation combines a value with a secret number using bitwise XOR (^^^).
  - This is part of the secret number evolution process in the Monkey Market simulation.

    @param value The value to mix into the secret number
    @param secret The current secret number
    @return The result of XORing value with secret
*)
let mix value secret = Int64.logxor value secret


(** Prunes the secret number by taking modulo 16777216

  - This function keeps the secret number within bounds by applying modulo operation.
  - Part of the secret number evolution process in the Monkey Market simulation.

    @param secret The secret number to prune
    @return The result of secret modulo 16777216L
*)
let prune secret = Int64.rem secret 16777216L



(** Generates the next secret number in the sequence using the monkey's algorithm

    Each secret number evolves through three transformations:
    1. Multiply by 64, mix (XOR), and prune (modulo 16777216)
    2. Divide by 32, mix (XOR), and prune (modulo 16777216)
    3. Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    @param secret The current secret number to evolve
    @return The next secret number in the sequence after applying all transformations
*)
let next secret =
    let secret = secret |> mix (Int64.mul secret 64L) |> prune
  in
    let secret = secret |> mix (Int64.div secret 32L) |> prune
  in
    secret |> mix (Int64.mul secret 2048L) |> prune





(** Calculates sum of 2000th secret number for each buyer 

    For each buyer's initial secret number, the function:
    {ol
    {- Generates 2000 new secret numbers using the monkey's algorithm}
    {- Takes the 2000th number in the sequence}
    {- Sums these numbers across all buyers}}

    The secret number evolution follows these steps:
    {ul
    {- Multiply by 64, mix, and prune}
    {- Divide by 32, mix, and prune}
    {- Multiply by 2048, mix, and prune}}

    @param initial_secrets Array of initial secret numbers for each buyer
    @return Sum of the 2000th secret number from each buyer's sequence
*)
let part1 initial_secrets =
  Array.fold_left 
    (fun sum initial -> 
      let nth_secret = ref initial in
      for _ = 1 to 2000 do
        nth_secret := next !nth_secret
      done;
      Int64.add sum !nth_secret)
    0L
    initial_secrets





(** Finds the optimal price pattern in the Monkey Exchange Market to maximize banana trades

    Algorithm steps:
    {ol
    {- Generate price sequences (0-9) for each buyer's next 2000 secret numbers}
    {- Calculate price changes between consecutive numbers}
    {- Find patterns of 4 consecutive price changes}
    {- Track total banana prices for each unique pattern}
    {- Return the maximum possible banana price achievable}}

    Price patterns are tracked as 4-tuples of consecutive price changes.
    Each change represents the difference between consecutive prices.
    The function uses parallel processing for generating sequences and changes.

    @param initial_secrets Array of initial secret numbers from each buyer
    @return Maximum number of bananas obtainable using the optimal price change pattern
*)







(** Parses the input string into an array of initial secret numbers
    
  - Takes a string input with one number per line and converts each line to an Int64.
  - Empty lines and whitespace are handled appropriately.

    @param input Raw input string with one number per line
    @return Array of Int64 values representing initial secret numbers
*)
let parse input =
  String.split_on_char '\n' input
  |> List.filter (fun s -> String.trim s <> "")
  |> List.map (fun line -> Int64.of_string (String.trim line))
  |> Array.of_list


