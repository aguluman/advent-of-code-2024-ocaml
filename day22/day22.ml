(** {1 Day 22: Monkey Market - Secret Number Trading Challenge}

    This module solves Advent of Code Day 22 challenge about predicting buyer behavior 
    in a monkey market. The module analyzes pseudorandom sequences of secret numbers 
    and price patterns to maximize banana trades.

    {2 Problem Details}
    
    - {b Input:} Initial secret numbers for each buyer in the Monkey Exchange Market
    - {b Part 1:} Calculate sum of 2000th secret number generated by each buyer's algorithm  
    - {b Part 2:} Find optimal price pattern to maximize banana trades across all buyers

    {2 Secret Number Evolution Process}
    Each secret number evolves through a three-step process:
    
    - Multiply by 64, mix (XOR), and prune (modulo 16777216)
    - Divide by 32, mix (XOR), and prune (modulo 16777216) 
    - Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    {b Implementation Note:} The solution uses parallel processing and efficient data 
    structures for performance optimization.

    @see <https://adventofcode.com/2024/day/22> Advent of Code 2024, Day 22
*)

open Domainslib


module PatternKey = struct
    type t = int64 * int64 * int64 * int64
    let compare = compare
    let hash = Hashtbl.hash
    let equal = (=)
  end 


(** Mixes two values using XOR operation 

  - The mixing operation combines a value with a secret number using bitwise XOR (^^^).
  - This is part of the secret number evolution process in the Monkey Market simulation.

    @param value The value to mix into the secret number
    @param secret The current secret number
    @return The result of XORing value with secret
*)
let mix value secret = Int64.logxor value secret


(** Prunes the secret number by taking modulo 16777216

  - This function keeps the secret number within bounds by applying modulo operation.
  - Part of the secret number evolution process in the Monkey Market simulation.

    @param secret The secret number to prune
    @return The result of secret modulo 16777216L
*)
let prune secret = Int64.rem secret 16777216L



(** Generates the next secret number in the sequence using the monkey's algorithm

    Each secret number evolves through three transformations:
    1. Multiply by 64, mix (XOR), and prune (modulo 16777216)
    2. Divide by 32, mix (XOR), and prune (modulo 16777216)
    3. Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    @param secret The current secret number to evolve
    @return The next secret number in the sequence after applying all transformations
*)
let next secret =
    let secret = secret |> mix (Int64.mul secret 64L) |> prune
  in
    let secret = secret |> mix (Int64.div secret 32L) |> prune
  in
    secret |> mix (Int64.mul secret 2048L) |> prune





(** Calculates sum of 2000th secret number for each buyer 

    For each buyer's initial secret number, the function:
    {ol
    {- Generates 2000 new secret numbers using the monkey's algorithm}
    {- Takes the 2000th number in the sequence}
    {- Sums these numbers across all buyers}}

    The secret number evolution follows these steps:
    {ul
    {- Multiply by 64, mix, and prune}
    {- Divide by 32, mix, and prune}
    {- Multiply by 2048, mix, and prune}}

    @param initial_secrets Array of initial secret numbers for each buyer
    @return Sum of the 2000th secret number from each buyer's sequence
*)
let part1 initial_secrets =
  Array.fold_left 
    (fun sum initial -> 
      let nth_secret = ref initial in
      for _ = 1 to 2000 do
        nth_secret := next !nth_secret
      done;
      Int64.add sum !nth_secret)
    0L
    initial_secrets





(** Finds the optimal price pattern in the Monkey Exchange Market to maximize banana trades

    Algorithm steps:
    {ol
    {- Generate price sequences (0-9) for each buyer's next 2000 secret numbers}
    {- Calculate price changes between consecutive numbers}
    {- Find patterns of 4 consecutive price changes}
    {- Track total banana prices for each unique pattern}
    {- Return the maximum possible banana price achievable}}

    Price patterns are tracked as 4-tuples of consecutive price changes.
    Each change represents the difference between consecutive prices.
    The function uses parallel processing for generating sequences and changes.

    @param initial_secrets Array of initial secret numbers from each buyer
    @return Maximum number of bananas obtainable using the optimal price change pattern
*)
let part2 initial_secrets =
  (* Create a task pool for parallel processing *)
  let pool = Domainslib.Task.setup_pool 
    ~num_domains:(Domain.recommended_domain_count() - 1) () in
  
  (* Process each buyer secret in parallel *)
  let local_results = 
    Task.run pool (fun () ->
      let initial_secrets_list = Array.to_list initial_secrets in
      let n = List.length initial_secrets_list in
      
      (* Convert to array for parallel_for compatibility *)
      let initial_secrets_array = Array.of_list initial_secrets_list in
      let results_array = Array.make n (Hashtbl.create 0) in
      
      Task.parallel_for pool ~start:0 ~finish:(n - 1) ~body:(fun i ->
        let buyer_secret = initial_secrets_array.(i) in
        (* Local hash tables for each domain *)
        let local_pattern_map = Hashtbl.create 1024 in
        let seen_patterns = Hashtbl.create 1024 in
        
        (* Generate the first 5 prices *)
        let current = ref buyer_secret in
        let prices = Array.make 5 0L in
        
        for i = 0 to 4 do
          prices.(i) <- Int64.rem !current 10L;
          current := next !current
        done;

          (* Create a sliding window of 4 changes (5 prices) *)
          let changes = Array.make 4 0L in
          
          for i = 0 to 3 do
            changes.(i) <- Int64.sub prices.(i + 1) prices.(i)
          done;
          
          (* Use integer hash code instead of tuple for better performance *)
          let pattern_to_int c1 c2 c3 c4 =
            (* Range of each change is -9 to 9 (19 possibilities) *)
            let c1_int = Int64.to_int c1 + 9 in
            let c2_int = Int64.to_int c2 + 9 in
            let c3_int = Int64.to_int c3 + 9 in
            let c4_int = Int64.to_int c4 + 9 in
            
            c1_int + (c2_int * 19) + (c3_int * 19 * 19) + (c4_int * 19 * 19 * 19)
          in
          
          (* Initial pattern *)
          let pattern_int = ref (pattern_to_int changes.(0) changes.(1) changes.(2) changes.(3)) in
          
          (* Process first pattern *)
          if not (Hashtbl.mem seen_patterns !pattern_int) then begin
            Hashtbl.add seen_patterns !pattern_int ();
            Hashtbl.add local_pattern_map !pattern_int prices.(4)
          end;
          
          (* Process remaining sequences with batch pre-generation *)
          let batch_size = 100 in
          
          (* Fixed the for loop with 'by' - using regular increments instead *)
          for i = 0 to (2000 - 5) / batch_size do
            let batch_start = 5 + (i * batch_size) in
            let batch_end = min 2000 (batch_start + batch_size - 1) in
            
            (* Pre-generate prices for this batch *)
            let batch_prices = Array.make (batch_end - batch_start + 1) 0L in
            let current_for_batch = ref !current in
            
            for i = 0 to Array.length batch_prices - 1 do
              batch_prices.(i) <- Int64.rem !current_for_batch 10L;
              current_for_batch := next !current_for_batch
            done;
            
            (* Update current to the last computed value *)
            current := !current_for_batch;
            
            (* Process batch *)
            for i = 0 to batch_end - batch_start do
              let price = batch_prices.(i) in
              
              (* Shift the window *)
              for j = 0 to 2 do
                changes.(j) <- changes.(j + 1)
              done;
              
              changes.(3) <- Int64.sub price prices.(4);
              
              (* Update prices *)
              for j = 0 to 3 do
                prices.(j) <- prices.(j + 1)
              done;
              
              prices.(4) <- price;
              
              (* Calculate new pattern using integer representation *)
              pattern_int := pattern_to_int changes.(0) changes.(1) changes.(2) changes.(3);
              
              (* Update pattern map *)
              if not (Hashtbl.mem seen_patterns !pattern_int) then begin
                Hashtbl.add seen_patterns !pattern_int ();
                
                if Hashtbl.mem local_pattern_map !pattern_int then
                  let existing = Hashtbl.find local_pattern_map !pattern_int in
                  Hashtbl.replace local_pattern_map !pattern_int (Int64.add existing price)
                else
                  Hashtbl.add local_pattern_map !pattern_int price
              end
            done
          done;
          
          results_array.(i) <- local_pattern_map
      );
      
      Array.to_list results_array
    )
  in
  
  (* Merge local results *)
  let final_pattern_map = Hashtbl.create 1024 in
  
  List.iter
    (fun local_map ->
      Hashtbl.iter
        (fun pattern_key value ->
          if Hashtbl.mem final_pattern_map pattern_key then
            let existing = Hashtbl.find final_pattern_map pattern_key in
            Hashtbl.replace final_pattern_map pattern_key (Int64.add existing value)
          else
            Hashtbl.add final_pattern_map pattern_key value
        )
        local_map
    )
    local_results;
  
  (* Find maximum value *)
  let max_value = ref 0L in
  
  Hashtbl.iter
    (fun _ value ->
      if Int64.compare value !max_value > 0 then
        max_value := value
    )
    final_pattern_map;
  
  Domainslib.Task.teardown_pool pool;
  !max_value





(** Parses the input string into an array of initial secret numbers
    
  - Takes a string input with one number per line and converts each line to an Int64.
  - Empty lines and whitespace are handled appropriately.

    @param input Raw input string with one number per line
    @return Array of Int64 values representing initial secret numbers
*)
let parse input =
  String.split_on_char '\n' input
  |> List.filter (fun s -> String.trim s <> "")
  |> List.map (fun line -> Int64.of_string (String.trim line))
  |> Array.of_list


