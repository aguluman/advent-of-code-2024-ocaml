(** {1 Day 22: Monkey Market - Secret Number Trading Challenge}

    This module solves Advent of Code Day 22 challenge about predicting buyer behavior 
    in a monkey market. The module analyzes pseudorandom sequences of secret numbers 
    and price patterns to maximize banana trades.

    {2 Problem Details}
    
    - {b Input:} Initial secret numbers for each buyer in the Monkey Exchange Market
    - {b Part 1:} Calculate sum of 2000th secret number generated by each buyer's algorithm  
    - {b Part 2:} Find optimal price pattern to maximize banana trades across all buyers

    {2 Secret Number Evolution Process}
    Each secret number evolves through a three-step process:
    
    - Multiply by 64, mix (XOR), and prune (modulo 16777216)
    - Divide by 32, mix (XOR), and prune (modulo 16777216) 
    - Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    {b Implementation Note:} The solution uses parallel processing and efficient data 
    structures for performance optimization.

    @see <https://adventofcode.com/2024/day/22> Advent of Code 2024, Day 22
*)

module PatternKey = struct
    type t = int64 * int64 * int64 * int64
    let compare = compare
    let hash = Hashtbl.hash
    let equal = (=)
  end 


(** Mixes two values using XOR operation 

  - The mixing operation combines a value with a secret number using bitwise XOR (^^^).
  - This is part of the secret number evolution process in the Monkey Market simulation.

    @param value The value to mix into the secret number
    @param secret The current secret number
    @return The result of XORing value with secret
*)
let mix value secret = Int64.logxor value secret


(** Prunes the secret number by taking modulo 16777216

  - This function keeps the secret number within bounds by applying modulo operation.
  - Part of the secret number evolution process in the Monkey Market simulation.

    @param secret The secret number to prune
    @return The result of secret modulo 16777216L
*)
let prune secret = Int64.rem secret 16777216L



(** Generates the next secret number in the sequence using the monkey's algorithm

    Each secret number evolves through three transformations:
    1. Multiply by 64, mix (XOR), and prune (modulo 16777216)
    2. Divide by 32, mix (XOR), and prune (modulo 16777216)
    3. Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    @param secret The current secret number to evolve
    @return The next secret number in the sequence after applying all transformations
*)
let next secret =
    let secret = secret |> mix (Int64.mul secret 64L) |> prune
  in
    let secret = secret |> mix (Int64.div secret 32L) |> prune
  in
    secret |> mix (Int64.mul secret 2048L) |> prune





(** Calculates sum of 2000th secret number for each buyer 

    For each buyer's initial secret number, the function:
    {ol
    {- Generates 2000 new secret numbers using the monkey's algorithm}
    {- Takes the 2000th number in the sequence}
    {- Sums these numbers across all buyers}}

    The secret number evolution follows these steps:
    {ul
    {- Multiply by 64, mix, and prune}
    {- Divide by 32, mix, and prune}
    {- Multiply by 2048, mix, and prune}}

    @param initial_secrets Array of initial secret numbers for each buyer
    @return Sum of the 2000th secret number from each buyer's sequence
*)
let part1 initial_secrets =
  Array.fold_left 
    (fun sum initial -> 
      let nth_secret = ref initial in
      for _ = 1 to 2000 do
        nth_secret := next !nth_secret
      done;
      Int64.add sum !nth_secret)
    0L
    initial_secrets





(** Finds the optimal price pattern in the Monkey Exchange Market to maximize banana trades

    Algorithm steps:
    {ol
    {- Generate price sequences (0-9) for each buyer's next 2000 secret numbers}
    {- Calculate price changes between consecutive numbers}
    {- Find patterns of 4 consecutive price changes}
    {- Track total banana prices for each unique pattern}
    {- Return the maximum possible banana price achievable}}

    Price patterns are tracked as 4-tuples of consecutive price changes.
    Each change represents the difference between consecutive prices.
    The function uses parallel processing for generating sequences and changes.

    @param initial_secrets Array of initial secret numbers from each buyer
    @return Maximum number of bananas obtainable using the optimal price change pattern
*)
let part2 initial_secrets =
  (* Create sequences of price digits (0-9) for each initial secret *)
  let sequences =
    Array.map (fun initial ->
      let numbers = Array.make 2001 0L in
      numbers.(0) <- Int64.rem initial 10L;
      
      (* Compute the sequence in place *)
      let current = ref initial in
      for i = 1 to 2000 do
        current := next !current;
        numbers.(i) <- Int64.rem !current 10L
      done;
      
      numbers
    ) initial_secrets
  in
  
  (* Calculate changes between consecutive numbers *)
  let changes =
    Array.map (fun seq ->
      Array.init 2000 (fun i -> Int64.sub seq.(i + 1) seq.(i))
    ) sequences
  in
  

  (* Create hashtable for patterns *)
  let pattern_map = Hashtbl.create 10000 in
  
  (* Process each buyer's changes *)
  for buyer_idx = 0 to Array.length changes - 1 do
    (* Use Hashtbl as an efficient set *)
    let seen_patterns = Hashtbl.create 1000 in
    
    (* Find patterns *)
    for i = 0 to Array.length changes.(buyer_idx) - 4 do
      let pattern = (
        changes.(buyer_idx).(i),
        changes.(buyer_idx).(i + 1),
        changes.(buyer_idx).(i + 2),
        changes.(buyer_idx).(i + 3)
      ) in
      
      if not (Hashtbl.mem seen_patterns pattern) then begin
        let next_price = sequences.(buyer_idx).(i + 4) in
        
        (* Update pattern map *)
        begin match Hashtbl.find_opt pattern_map pattern with
        | None -> Hashtbl.add pattern_map pattern next_price
        | Some existing -> Hashtbl.replace pattern_map pattern (Int64.add existing next_price)
        end;
        
        (* Mark pattern as seen *)
        Hashtbl.add seen_patterns pattern true
      end
    done
  done;
  
  (* Find maximum sum *)
  Hashtbl.fold (fun _ value max_value ->
    if Int64.compare value max_value > 0 then value else max_value
  ) pattern_map 0L






(** Parses the input string into an array of initial secret numbers
    
  - Takes a string input with one number per line and converts each line to an Int64.
  - Empty lines and whitespace are handled appropriately.

    @param input Raw input string with one number per line
    @return Array of Int64 values representing initial secret numbers
*)
let parse input =
  String.split_on_char '\n' input
  |> List.filter (fun s -> String.trim s <> "")
  |> List.map (fun line -> Int64.of_string (String.trim line))
  |> Array.of_list


