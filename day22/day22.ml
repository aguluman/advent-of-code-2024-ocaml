(** {1 Day 22: Monkey Market - Secret Number Trading Challenge}

    This module solves Advent of Code Day 22 challenge about predicting buyer behavior 
    in a monkey market. The module analyzes pseudorandom sequences of secret numbers 
    and price patterns to maximize banana trades.

    {2 Problem Details}
    
    - {b Input:} Initial secret numbers for each buyer in the Monkey Exchange Market
    - {b Part 1:} Calculate sum of 2000th secret number generated by each buyer's algorithm  
    - {b Part 2:} Find optimal price pattern to maximize banana trades across all buyers

    {2 Secret Number Evolution Process}
    Each secret number evolves through a three-step process:
    
    - Multiply by 64, mix (XOR), and prune (modulo 16777216)
    - Divide by 32, mix (XOR), and prune (modulo 16777216) 
    - Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    {b Implementation Note:} The solution uses parallel processing and efficient data 
    structures for performance optimization.

    @see <https://adventofcode.com/2024/day/22> Advent of Code 2024, Day 22
*)

open Domainslib


module PatternKey = struct
    type t = int64 * int64 * int64 * int64
    let compare = compare
    let hash = Hashtbl.hash
    let equal = (=)
  end 


(** Mixes two values using XOR operation 

  - The mixing operation combines a value with a secret number using bitwise XOR (^^^).
  - This is part of the secret number evolution process in the Monkey Market simulation.

    @param value The value to mix into the secret number
    @param secret The current secret number
    @return The result of XORing value with secret
*)
let mix value secret = Int64.logxor value secret


(** Prunes the secret number by taking modulo 16777216

  - This function keeps the secret number within bounds by applying modulo operation.
  - Part of the secret number evolution process in the Monkey Market simulation.

    @param secret The secret number to prune
    @return The result of secret modulo 16777216L
*)
let prune secret = Int64.rem secret 16777216L



(** Generates the next secret number in the sequence using the monkey's algorithm

    Each secret number evolves through three transformations:
    1. Multiply by 64, mix (XOR), and prune (modulo 16777216)
    2. Divide by 32, mix (XOR), and prune (modulo 16777216)
    3. Multiply by 2048, mix (XOR), and prune (modulo 16777216)

    @param secret The current secret number to evolve
    @return The next secret number in the sequence after applying all transformations
*)
let next secret =
    let secret = secret |> mix (Int64.mul secret 64L) |> prune
  in
    let secret = secret |> mix (Int64.div secret 32L) |> prune
  in
    secret |> mix (Int64.mul secret 2048L) |> prune





(** Calculates sum of 2000th secret number for each buyer 

    For each buyer's initial secret number, the function:
    {ol
    {- Generates 2000 new secret numbers using the monkey's algorithm}
    {- Takes the 2000th number in the sequence}
    {- Sums these numbers across all buyers}}

    The secret number evolution follows these steps:
    {ul
    {- Multiply by 64, mix, and prune}
    {- Divide by 32, mix, and prune}
    {- Multiply by 2048, mix, and prune}}

    @param initial_secrets Array of initial secret numbers for each buyer
    @return Sum of the 2000th secret number from each buyer's sequence
*)
let part1 initial_secrets =
  Array.fold_left 
    (fun sum initial -> 
      let nth_secret = ref initial in
      for _ = 1 to 2000 do
        nth_secret := next !nth_secret
      done;
      Int64.add sum !nth_secret)
    0L
    initial_secrets





(** Finds the optimal price pattern in the Monkey Exchange Market to maximize banana trades

    Algorithm steps:
    {ol
    {- Generate price sequences (0-9) for each buyer's next 2000 secret numbers}
    {- Calculate price changes between consecutive numbers}
    {- Find patterns of 4 consecutive price changes}
    {- Track total banana prices for each unique pattern}
    {- Return the maximum possible banana price achievable}}

    Price patterns are tracked as 4-tuples of consecutive price changes.
    Each change represents the difference between consecutive prices.
    The function uses parallel processing for generating sequences and changes.

    @param initial_secrets Array of initial secret numbers from each buyer
    @return Maximum number of bananas obtainable using the optimal price change pattern
*)
let part2 initial_secrets =
  (* Create a task pool with a reasonable number of domains *)
  let num_domains = 
    try int_of_string (Sys.getenv "NUMBER_OF_PROCESSORS") 
    with _ -> 4 
  in
  let num_domains = max 2 (min num_domains 8) in
  
  (* Setup thread pool *)
  let pool = Task.setup_pool ~num_domains () in
  
  
  Task.run pool (fun _ ->
    (* Step 1: Generate sequences in parallel *)
    let sequences =
      let buyer_count = Array.length initial_secrets in
      let result = Array.make buyer_count [||] in
      
      Task.parallel_for pool ~start:0 ~finish:(buyer_count - 1) ~body:(fun i ->
        let initial = initial_secrets.(i) in
        let numbers = Array.make 2001 0L in
        numbers.(0) <- Int64.rem initial 10L;
        
        let current = ref initial in
        for j = 1 to 2000 do
          current := next !current;
          numbers.(j) <- Int64.rem !current 10L
        done;
        
        result.(i) <- numbers
      );
      result
    in
    
    (* Step 2: Calculate changes in parallel *)
    let changes =
      let buyer_count = Array.length sequences in
      let result = Array.make buyer_count [||] in
      
      Task.parallel_for pool ~start:0 ~finish:(buyer_count - 1) ~body:(fun i ->
        result.(i) <- Array.init 2000 (fun j -> Int64.sub sequences.(i).(j + 1) sequences.(i).(j))
      );
      result
    in
    
    (* Step 3: Process patterns using a shared table with locking *)
    let pattern_map = Hashtbl.create 10000 in
    let pattern_mutex = Mutex.create () in  (* For thread-safe updates *)
    
    Task.parallel_for pool ~start:0 ~finish:(Array.length changes - 1) ~body:(fun buyer_idx ->
      let seen_patterns = Hashtbl.create 1000 in
      let local_patterns = Hashtbl.create 1000 in
      
      for i = 0 to Array.length changes.(buyer_idx) - 4 do
        let pattern = (
          changes.(buyer_idx).(i),
          changes.(buyer_idx).(i + 1),
          changes.(buyer_idx).(i + 2),
          changes.(buyer_idx).(i + 3)
        ) in
        
        if not (Hashtbl.mem seen_patterns pattern) then begin
          let next_price = sequences.(buyer_idx).(i + 4) in
          
          (* Update local pattern map *)
          begin match Hashtbl.find_opt local_patterns pattern with
          | None -> Hashtbl.add local_patterns pattern next_price
          | Some existing -> Hashtbl.replace local_patterns pattern (Int64.add existing next_price)
          end;
          
          (* Mark pattern as seen *)
          Hashtbl.add seen_patterns pattern true
        end
      done;
      
      (* Merge local results into global map with mutex protection *)
      Mutex.lock pattern_mutex;
      Hashtbl.iter (fun pattern value ->
        match Hashtbl.find_opt pattern_map pattern with
        | None -> Hashtbl.add pattern_map pattern value
        | Some existing -> Hashtbl.replace pattern_map pattern (Int64.add existing value)
      ) local_patterns;
      Mutex.unlock pattern_mutex;
    );
    
    (* Find maximum sum *)
    let result = Hashtbl.fold (fun _ value max_value ->
      if Int64.compare value max_value > 0 then value else max_value
    ) pattern_map 0L in
    
    result
  )






(** Parses the input string into an array of initial secret numbers
    
  - Takes a string input with one number per line and converts each line to an Int64.
  - Empty lines and whitespace are handled appropriately.

    @param input Raw input string with one number per line
    @return Array of Int64 values representing initial secret numbers
*)
let parse input =
  String.split_on_char '\n' input
  |> List.filter (fun s -> String.trim s <> "")
  |> List.map (fun line -> Int64.of_string (String.trim line))
  |> Array.of_list


